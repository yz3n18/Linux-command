<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" class="no-js" xml:lang="en">
<head>
<script type="text/javascript" src="//use.typekit.com/ccz1grx.js"></script>
<script type="text/javascript">try{Typekit.load();}catch(e){}</script><script type="text/javascript">  document.documentElement.className += " js";</script>
<script type="text/javascript">
$(document).ready(function() {
    // can use links inside div.oembed too since "a" don't work for tinymce styles
    $("a.oembed,.oembed a").oembed(null, jqueryOmebedSettings);
});
</script>
<title>Lecture01: An Introduction to Unix</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
</head>

<body>

<style>
body {font-size: 1.75em; width: 85%; padding-left: 7.5%;}
code {padding: 2px 4px;color: #d14;background-color: #f7f7f9;border: 1px solid #e1e1e8;}
ul,ol {list-style-position: inside;}
a{ color: #0072cf; text-decoration:none;border-bottom:0;outline: none;}
</style>

<h1>Lecture01: An Introduction to Unix</h1>
<br/><br/><br/><br/><br/><br/>
Who has done Unix before?!
<br/><br/><br/><br/><br/><br/>
<br/><br/>
<br/><br/>
<br/><br/>

<!-- PAGE MARKER -->
<p style="page-break-after: always;">&nbsp;</p><br/><br/><br/><br/><br/><hr><br/>

<h3>  <a href="http://129.215.170.35/BPSM.html">http://129.215.170.35/BPSM.html</a> </h3>
<br />
<br />Today we are going to "refreshen" our knowledge of Unix commands, and then use them to extract bits of information from a text file.  
<br /><br />I have tried to make this guide as generally valid as possible, but there are many different flavours/versions of Unix available, so if you should find a command option behaving differently on your local machine you should consult the on-line manual page for that command (we'll see how later). 
<br /><br />Most of the commands have numerous additional options that I have not mentioned, so for fuller information on these commands use the relevant on-line manual page.<br />
<br /><br />The names of commands are printed in bold, and the names of objects operated on by these commands (e.g. files, directories) are printed in teletype.<br />

<!-- PAGE MARKER -->
<p style="page-break-after: always;">&nbsp;</p><br/><br/><br/><br/><br/><hr><br/>
<h2>Index of Commands</h2>
<table><tbody>
<tr align="left"><td>

<a href="#awk">awk</a> - pattern scanning and processing language<br /><br />
<a href="#cat">cat, zcat</a> - display or concatenate files<br /><br />
<a href="#cd">cd</a> - change directory<br /><br />
<a href="#chmod">chmod</a> - change the permissions on a file or directory<br /><br />
<a href="#cp">cp</a> - copy a file<br /><br />
<a href="#cut">cut</a> - extract sections from each line of input<br /><br />
<a href="#date">date</a> - display the current date and time<br /><br />
<!--
<a href="#diff">diff,zdiff</a> - display differences between text files<br /><br />
<a href="#file">file</a> - determine the type of a file<br /> <br />
-->
<a href="#find">find</a> - find files of a specified name or type<br /><br />
<a href="#ftp">ftp</a> - file transfer program<br /><br />
<a href="#grep">grep, zgrep</a> - searches files for a specified string or expression<br /><br />
<a href="#gzip">gzip</a> - compress a file<br /><br />
<a href="#head">head, tail</a> - display lines/characters from a file<br /><br />
<!--
<a href="#help">help</a> - display information about bash built-in commands<br /><br />
<a href="#info">info</a> - read online documentation<br /> <br />
-->
<a href="#kill">kill</a> - kill a process<br /><br />
<!--
<a href="#lpr">lpr</a> - print out a file<br /><br />
-->
<a href="#ls">ls</a> - list names of files in a directory<br /><br />
<a href="#man">man</a> - display an on-line manual page<br /><br />
</td><td>
<a href="#mkdir">mkdir</a> - make a directory<br /><br />
<a href="#more">more, zmore</a> - scan through a text file page by page<br /><br />
<a href="#mv">mv</a> - move or rename files or directories<br /><br />
<!--
<a href="#nice">nice</a> - change the priority at which a job is being run<br /><br />
-->
<a href="#passwd">passwd</a> - change your password<br /><br />
<a href="#paste">paste</a> - join files horizontally<br /><br />
<a href="#ps">ps</a> - list processes<br /><br />
<a href="#pwd">pwd</a> - display the name of your current directory<br /><br />
<!--
<a href="#quota">quota</a> - disk quota and usage<br /><br />
-->
<a href="#rm">rm</a> - remove files or directories<br /><br />
<a href="#rmdir">rmdir</a> - remove a directory<br /><br />
<a href="#sort">sort</a> - sort and collate lines<br /><br />
<a href="#ssh">ssh, scp</a> - secure remote access<br /><br />
<a href="#tar">tar</a> - create and use archives of files<br /><br />
<a href="#uniq">uniq</a> - unique <br /><br />
<a href="#wc">wc</a> - counting words, letters, lines of files<br /></td>
</tr></tbody></table>


<!-- PAGE MARKER -->
<p style="page-break-after: always;">&nbsp;</p><br/><br/><br/><br/><br/><hr><br/>

<h2><a name="awk" id="awk">awk</a> - Pattern scanning and processing language</h2>
A whole language in itself, invoking <code><b>awk</b></code> can very useful as part of a pipe (series of linked commands).  <code><b>awk</b></code> can filter rows based on column criteria or pattern matching, use arrays, functions, etc. etc.. 
<br/><br/>In <code>awk</code>, the notation <code>$1</code> means the contents of the first field, <code>$2</code> means the second field, etc.  
<br/><br/>For awk, the default field separator <code>FS</code> is a <b>space</b>, but we can tell it to use something else if we want.
<pre>

The prickly hedgehog was hibernating.
 $1   $2        $3   $4     $5       (fields)

The	prickly	hedgehog	was	hibernating.
$1   	$2	$3		$4	$5       (fields)

</pre>
Text tables are frequently tab-delimited...

<!-- PAGE MARKER -->
<p style="page-break-after: always;">&nbsp;</p><br/><br/><br/><br/><br/><hr><br/>

<dl>
<dt><code><b>awk</b> '($3 == 5)' file1</code></dt><dd>output rows of <code>file1</code> where the third field/column has a value equal to 5; this <u>assumes</u> that the field separator is a <b>space</b>.  This command acts as a filtering step, and in these instances, the evaluation command is surrounded by ordinary <code>(</code> and <code>)</code> brackets inside the quotes.</dd>
<br/><dt><code><b>awk</b> '{FS="\t"; if($3 == 5){print $0;}}' file1</code></dt><dd>first, we have told awk that the field separator is a <b>tab</b>, which is written as "\t"; awk will then output rows ($0 means the whole line) where the third column of <code>file1</code> has a value equal to 5.</dd>
<br/>This command is evaluating, and then doing something based on the evaluation, and thus is an action command.  As this is an action, these commands have <code>{</code> and <code>}</code> curly brackets inside the quotes.</dd>
<!-- PAGE MARKER -->
<p style="page-break-after: always;">&nbsp;</p><br/><br/><br/><br/><br/><hr><br/>

<dt><code><b>awk</b> '{FS="\t"; if($3 == "foobar1"){print $0;}}' file1</code></dt><dd>first, we have told awk that the field separator (FS) is a <b>tab</b>; awk will then output rows where the third column of <code>file1</code> is the text string "foobar1" (but not if it is foobar or foobar2)</dd>

<br/><dt><code><b>awk</b> '{FS="\t"; OFS="_"; if($3 == "foobar1"){print $1,$2,$3;}}' file1</code></dt>
<dd>first, we have told awk that the field separator is a <b>tab</b>; we have also told awk that the output field separator (OFS) should be
 an underscore.  <br/>awk will then output the first, second and third fields ($1,$2,$3) of rows/lines of the file where the third column of <code>file1</code> is the text string is exactly "foobar1"; any output fields will be separated by underscores. </dd>
<pre><code><b>If file1 was these three lines of tab-delimited text:</b>
F1	AS top one	foobar1	X0
F2	AS mid	foobar12	Y9
F3	AS bottom sample from the dataset	foobar	H3

<b>the output would be</b> 
F1_AS top one_foobar1</code></pre>

<!-- PAGE MARKER -->
<p style="page-break-after: always;">&nbsp;</p><br/><br/><br/><br/><br/><hr><br/>

<br/><dt><code><b>awk</b> '{FS="_"; print NF;}' file1</code></dt>
<dd>for each line of <code>file1</code>, using underscore "_" as field separator, output the <b>number</b> of fields on the line.</dd>

<br/><dt><code><b>awk</b> '{FS=" "; print "There are",NF,"fields on this line.";}' file1</code></dt>
<dd>for each line of <code>file1</code>, using space " " as field separator, output a short sentence indicating the <b>number</b> of fields on the line.</dd>

<br/><dt><code><b>awk</b> '{FS="XXX"; print "The last field on this line is",$NF ;}' file1</code></dt>
<dd>for each line of <code>file1</code>, using "XXX" as field separator, output a short sentence that tells us what the <b>actual</b> last field on each line was.</dd>


<!-- PAGE MARKER -->
<p style="page-break-after: always;">&nbsp;</p><br/><br/><br/><br/><br/><hr><br/>


<dt><code><b>awk</b> '{FS="\t"; if($3 == "United Kingdom"){print $0;}}' file1 > file2</code></dt>
<dd>For each line, tell awk that field separator is tab.  Determine if the third field/column of <code>file1</code> is "United Kingdom" and if so, save the whole line to <code>file2</code>.</dd>

<br/><br/>

<br/><dt><code><b>awk</b> '{FS=" "; if($3 == "United Kingdom"){print $0;}}' file1 > file2</code></dt>
<dd>Field separator is space.  Determine if the third field/column of <code>file1</code> is "United Kingdom" and if so, save the whole line to <code>file2</code>.
<br/>We have specified that the field separator is a space.  This makes no sense as "United Kingdom" would be two fields, as the separator is a space!  
You will <b>NOT</b> get the same answer as in the previous code line!</dd>

<!-- PAGE MARKER -->
<p style="page-break-after: always;">&nbsp;</p><br/><br/><br/><br/><br/><hr><br/>
When awk code gets long, it is best to put it on several lines.  Awk doesnt require you to do this, but it makes it easier to spot coding errors!  And PDFs are much better....!
<br/><br/><dt><code><b>## My first short awk script<br/>awk</b> 'BEGIN{FS="\t";}<br/>{<br/>if(substr($3,1,3) == "Uni")<br/><dd>{print $1;}</dd>}' file1 >> file2 </code></dt>
<dd><br/>A brief comment line<br/><br/>Field separator is tab (telling awk only once).<br/><br/>Determine if the first three characters (a sub-string) of the third field/column (separated by tabs) of <code>file1</code> are "Uni" and if so, save the first field <u>onto the end of</u> <code>file2</code>.  
<br/><br />Curly brackets <code>{</code>  <code>}</code> for the action, ordinary <code>(</code> <code>)</code> brackets for the evaluation.</dd>
</dl>

<!-- PAGE MARKER -->
<p style="page-break-after: always;">&nbsp;</p><br/><br/><br/><br/><br/><hr><br/>

<h2><a name="cat" id="cat">cat, zcat</a> - display or concatenate files</h2>
<p><b><code>cat</code></b> takes content of a file and sends it to the standard output (i.e. screen, unless redirected elsewhere)<br />Generally used either to read files, or to string together copies of several files, writing the output to a new file.</p>
<dl>
<dt><code><b>cat</b> ex1</code></dt><dd>displays the contents of the file <code>ex1</code></dd>
<dt><code><b>zcat</b> ex1.gz</code></dt><dd>works the same as <code>cat</code>, but takes a gzipped file as input, then uncompresses "on the fly" to the screen, file still compressed.</dd>

<dt><code><b>cat</b> ex1 ex2 <b>&gt;</b> newex</code></dt><dd>creates a new file <code>newex</code> containing copies of <code>ex1</code> and <code>ex2</code>, with the contents of <code>ex2</code> following the contents of <code>ex1</code></dd>
<dt><code><b>cat</b> ex3 <b>&gt;&gt;</b> newex</code></dt><dd>adds (appends) the contents of <code>ex3</code> to the contents of <code>newex</code>, thus contents of <code>newex</code> are now <code>ex1</code> <code>ex2</code> <code>ex3</code><dd>
</dl>

<!-- PAGE MARKER -->
<p style="page-break-after: always;">&nbsp;</p><br/><br/><br/><br/><br/><hr><br/>

<h2><a name="pwd" id="pwd">pwd</a> - display the name of your current directory (folder)
<br/><a name="cd" id="cd">cd</a> - change directory (folder)</h2>
The command <code><b>pwd</b></code> gives the full pathname of your current directory.
<br/><code><b>cd</b></code> is used to change from one directory to another.

<dl>
<dt><code><b>cd</b> dir1</code></dt><dd>changes directory so that <code>dir1</code> is your new current directory. <code>dir1</code> may be either the full pathname of the directory, or its pathname relative to the current directory.</dd>
<dt><code><b>cd</b></code></dt><dd>changes directory to your home directory.</dd>
<dt><code><b>cd -</b></code></dt><dd>changes directory to the previous directory you were in.</dd>
<dt><b><code>cd ..</code></b></dt><dd>changes directory to the parent directory of your current directory, i.e up one level.</dd>
<dt><b><code>cd ../..</code></b></dt><dd>changes directory to the "grand-parent" directory of your current directory, i.e up two levels.</dd>
</dl>


<!-- PAGE MARKER -->
<p style="page-break-after: always;">&nbsp;</p><br/><br/><br/><br/><br/><hr><br/>

<h2><a name="chmod" id="chmod">chmod</a> - change the permissions on a file or directory</h2>

A directory listing generated using <code>ls -al</code> might look like this:
<pre>
-rw-rw-r-- 1 someuser  somegroup  2015 Oct 14  2020 dna.txt
-rw-rw-r-- 1 someuser  somegroup    28 Oct  2  2020 exons.txt
-rw-rw-r-- 1 someuser  somegroup   485 Oct  2  2020 genomic_dna1.txt
-rw-rw-r-- 1 someuser2 admin       124 Sep 30  2020 plasmid_dna1.text
-rw-rw-r-- 1 someuser2 admin       124 Sep 30  2020 plasmid_dna1.foo
</pre>
<p><code><b>chmod</b></code> enables us to alter the permissions on files and directories using either symbolic or octal numeric codes. 
Note that you can only change these values on files that you own! <br/>

<!-- PAGE MARKER -->
<p style="page-break-after: always;">&nbsp;</p><br/><br/><br/><br/><br/><hr><br/>

The symbolic codes are:</p>
<pre>
<b>u</b>  user    <b>+</b>  to add a permission                   <b>r</b>  read
<b>g</b>  group   <b>-</b>  to remove a permission                <b>w</b>  write
<b>o</b>  other   <b>=</b>  to assign a permission explicitly     <b>x</b>  execute (for files),
                                                       access (for directories)
</pre>
<p>The following examples illustrate how these codes are used.</p>
<dl>
<dt><code><b>chmod u=rw</b> dna.txt</code></dt><dd>sets the permissions on the file <code>dna.txt</code> to give the user read and write permission on <code>dna.txt</code>. No other permissions are altered.</dd>
<dt><code><b>chmod u+x,g+w,o-r</b> dna.txt</code></dt><dd>alters the permissions on the file <code>dna.txt</code> to give the user execute permission on <code>dna.txt</code>, to give members of the user's group write permission on the file, and prevent any users not in this group from reading it.</dd>
<dt><code><b>chmod u+w,go-x</b> dir1</code></dt><dd>gives the user write permission in the directory <code>dir1</code>, and prevents all other users having access to that directory (by using <code><b>cd</b></code>. 
They can still list its contents using <code>ls</code>, however.)</dd>
</dl>

<!-- PAGE MARKER -->
<p style="page-break-after: always;">&nbsp;</p><br/><br/><br/><br/><br/><hr><br/>

Files have permission values in octal format too, namely:
<pre>
     4	read
     2	write
     1	execute
</pre> so we can associate combinations (sums) of these values to "user", "group" and "other/world" categories to control what can and can't be done with a file.
<dl>
<dt><code>chmod 741 dna.txt</code></dt><dd>changes the permissions on <code>dna.txt</code> to be rwx for user (4+2+1), r-- (read-only, can't write or run) for the group, and --x (executable only, can't read or write) for the world <br/><pre>   -rwx r-- --x </pre></dd>
<dt><code>chmod 750 dna.txt</code></dt><dd>changes the permissions on <code>dna.txt</code> to be rwx for user (4+2+1), r-x (read-only, but executable, 4+1) for the group, and --- (no permissions at all) for the world <br/><pre>   -rwx r-x ---  </pre></dd>
</dl>

<!-- PAGE MARKER -->
<p style="page-break-after: always;">&nbsp;</p><br/><br/><br/><br/><br/><hr><br/>

<h2><a name="cp" id="cp">cp</a> - copy a file</h2>
The command <code><b>cp</b></code> is used to make copies of files and directories (folders).  Remember, each and every file has:
<ol>
<li>a <b>path</b>, default is "where you are right now on the filesystem"</li>
<li>a <b>name</b>, there is no default here!</li>
</ol>
When copying a file or directory, there has to be a source (where from?) and a destination (where to?)!
<dl>
<dt><code><b>cp</b> file1 file2</code></dt><dd>copies the contents of the file <code>file1</code> into a new file called <code>file2</code>.<br/>We havent given a path for either <code>file1</code> or <code>file2</code>, so the assumption of "where I am now" is made for both by default.<br/>Note that <code><b>cp</b></code> cannot copy a file onto itself.</dd>
<br/>
<dt><code><b>cp</b> file3 file4 dir1</code></dt><dd>creates copies (with the same names) of <code>file3</code> and <code>file4</code> in the directory <code>dir1</code>. 
<br/>We haven't given a path for either <code>file3</code> or <code>file4</code>, so the assumption of "where I am now" is made for both by default.<br/>
<code>dir1</code> must already exist for the copying to succeed.</dd>

<!-- PAGE MARKER -->
<p style="page-break-after: always;">&nbsp;</p><br/><br/><br/><br/><br/><hr><br/>
<dt><code><b>cp</b> dir1/file3 . </code></dt><dd>copies <code>file3</code> in <code>dir1</code> to where you are, i.e the dot means "present working directory".</dd>
<br/><dt><code><b>cp</b> dir1/file3 dir2/file4 </code></dt><dd>copies <code>file3</code> in <code>dir1</code> to <code>file4</code> in <code>dir2</code>.</dd>
<br/><dt><code><b>cp -u</b> file3 dir1</code></dt><dd>if source <code>file3</code> is newer than the destination <code>file3</code> or when the destination <code>file3</code> is missing, updates copy of <code>file3</code> within the directory <code>dir1</code>. <code>dir1</code> must already exist for the copying to succeed.</dd>
<br/><dt><code><b>cp -r</b> dir2 dir3</code></dt><dd>recursively copies the directory <code>dir2</code>, together with its contents and subdirectories, to the directory <code>dir3</code>.
<br/>If <code>dir3</code> does not exist, it is created by <code><b>cp</b></code>, and the contents and subdirectories of <code>dir2</code> are recreated within it. 
<br/>If <code>dir3</code> does exist, a subdirectory called <code>dir2</code> is created within it, containing a copy of all the contents of the original <code>dir2</code>.</dd>
</dl>

<!-- PAGE MARKER -->
<p style="page-break-after: always;">&nbsp;</p><br/><br/><br/><br/><br/><hr><br/>

<h2><a name="cut" id="cut">cut</a> - extract sections from each line of input</h2>
<p>The command <code><b>cut</b></code> is used to extract sections from each line of input; this can be done at the level of bytes (-b), characters (-c), or fields (-f) separated by a delimiter (-d, the tab character by default).</p>
<dl>
<dt><code><b>cut -c 3-12</b> file1</code></dt><dd>output characters 3 to 12 of each line of <code>file1</code>.</dd>
<br/><dt><code><b>cut -f 3,5,9 </b>file1</code></dt><dd>output fields 3, 5 and 9 of each line of <code>file1</code>.  Assumes tab delimiter.</dd>
<br/><dt><code><b>cut -d "_" -f 4- </b>file1</code></dt><dd> output the fourth and upwards "_" separated field of each line of <code>file1</code></dd>
<br/>If <code>file1</code> contained this single line of text:
<dd><pre>
this_is_not_a_silly_sentence
</pre></dd>
the output of <code><b>cut -d "_" -f 4- </b>file1</code> would be:
<dd><pre>
a_silly_sentence
</pre></dd>
the output of <code><b>cut -d "_" -f 5 </b>file1</code> would be:
<dd><pre>
silly
</pre></dd>
</dl>

<!-- PAGE MARKER -->
<p style="page-break-after: always;">&nbsp;</p><br/><br/><br/><br/><br/><hr><br/>

<h2><a name="date" id="date">date</a> - display the current date and time</h2>
<dl>
<dt><code><b>date</b></code></dt><dd>returns information on the current date and time in the format shown below<br /><code>Mon Jul 18 11:23:56 BST 2016</code></dd>
<br/><dt><code><b>date -u</b></code></dt><dd>returns information on the current date and time in Coordinated Universal Time (UTC) format (GMT is a time <b>zone</b> and UTC is a time <b>standard</b>.)<br /><code>Mon Jul 18 10:23:56 UTC 2016</code></dd>
<br/><br/>The official abbreviation for Coordinated Universal Time is UTC. It came about in 1967 as a compromise between English and French speakers.
<ul><li>In English,Coordinated Universal Time, abbreviated CUT.</li>
<li>En fran&ccedil;ais, Temps Universel Coordonn&eacute;, abbreviated TUC. </li></ul>
The International Telecommunication Union (ITU) and the International Astronomical Union (IAU) designated one single abbreviation for use in all languages: UTC.
<br/><br/><a href="https://www.timeanddate.com/time/aboututc.html">https://www.timeanddate.com/time/aboututc.html</a>

<!-- PAGE MARKER -->
<p style="page-break-after: always;">&nbsp;</p><br/><br/><br/><br/><br/><hr><br/>

<br/>It is possible to alter the format of the output from date. For example, using the command line
<br/><br/><dt><code><b>date '+The date is %d/%m/%y, and the time is %H:%M:%S.'</b></code></dt><dd>at exactly 11.30am on 30th January 2020, would produce the output<br/><code>The date is 30/01/20, and the time is 11:30:00.</code></dd>
<br/>To show the time in seconds since 1970-01-01 (Unix epoch time):
<br/><br/><dt><code><b>date +%s</b></code></dt><dd>returns a number like <code>1505483716</code></dd>
</dl>
<!--
<h2><a name="diff" id="diff">diff, zdiff</a> - display differences between text files</h2>
<dl>
<dt><code><b>diff</b> file1 file2</code></dt><dd>reports line-by-line differences between the text files <code>file1</code> and <code>file2</code>. </dd>
<dt><code><b>zdiff</b> file1.gz file2.gz</code></dt><dd>reports line-by-line differences between the compressed text files <code>file1.gz</code> and <code>file2.gz</code>. </dd>
<p>The default output will contain lines such as <dd><code><b>n1 a n2,n3</b></code></dd> and <dd><code><b>n4,n5 c n6,n7</b></code></dd>  
where n1 a n2,n3 means that <code>file2</code> has the extra lines n2 to n3 following the line that has the number n1 in file1, and <code><b>n4,n5 c n6,n7</b></code> means that lines n4 to n5 in <code><b>file1</b></code> differ from lines n6 to n7 in <code>file2</code>. After each such line, <code><b>diff</b></code> prints the relevant lines from the text files, with <code><b>&lt;</b></code> in front of each line from <code>file1</code> and <code><b>&gt;</b></code> in front of each line from <code>file2</code>.</p>
<p>There are several options to <code><b>diff</b></code>, including 

<dt><code><b>diff -i</b></code></dt><dd>ignores the case of letters when comparing lines.</dd>
<dt><code><b>diff -b</b></code></dt><dd>ignores all trailing blanks.</dd>
<dt><code><b>diff -c</b>n</code></dt><dd>produces a listing of differences with <code>n</code> lines of context, where the default is three lines. The form of the output is different from that given by <b><code>diff</code></b>, with <b><code>+</code></b> indicating lines which have been added, <b><code>-</code></b> indicating lines which have been removed, and <b><code>!</code></b> indicating lines which have been changed.</dd>
<dt><code><b>diff</b> dir1 dir2</code></dt><dd>will sort the contents of directories <code>dir1</code> and <code>dir2</code> by name, and then run <code><b>diff</b></code> on the text files which differ.</dd>
<dl>

<h2><a name="file" id="file">file</a> - determine the type of a file</h2>
<p><b><code>file</code></b> tests named files to determine the categories their contents belong to.</p>
<dl>
<dt><code><b>file</b> file1</code></dt><dd>can tell if <code>file1</code> is, for example, a source program, an executable program or shell script, an empty file, a directory, or a library, but (a warning!) it does sometimes make mistakes.</dd>
<dl>
-->

<!-- PAGE MARKER -->
<p style="page-break-after: always;">&nbsp;</p><br/><br/><br/><br/><br/><hr><br/>

<h2><a name="find" id="find">find</a> - find files of a specified name or type</h2>
<p><code><b>find</b></code> searches for files in a named directory and all its subdirectories.</p>
<dl>
<dt><code><b>find . -name</b> '*.f' </code></dt><dd>searches the current directory and all its subdirectories for files ending in <code>.f</code>, and writes their names to the standard output. In some versions of Unix the names of the files will only be written out if the <code><b>-print</b></code> option is used.</dd>
<br/>
<dt><code><b>find</b> /local <b>-name</b> core <b>-user</b> user1 </code></dt><dd>searches the directory <code>/local</code> and its subdirectories for files called <code>core</code> belonging to the user <code>user1</code> and writes their full file names to the standard output.</dd>
<dl>

<!-- PAGE MARKER -->
<p style="page-break-after: always;">&nbsp;</p><br/><br/><br/><br/><br/><hr><br/>

<h2><a name="ftp" id="ftp">ftp</a> - file transfer program</h2>
<p><b><code>ftp</code></b> is an interactive file transfer program. 
While logged on to one system (described as the local system), <b><code>ftp</code></b> is used to log on to another system (described as the remote system) that files are to be transferred to or from. 
As well as file transfers, it allows the inspection of directory contents on the remote system.  
There are numerous options and commands associated with <b><code>ftp</code></b>, and <b><code>man ftp</b></code> will give details of those.</p>

<p><b>WARNING!</b> When you use <b><code>ftp</code></b> the communications between the systems are not encrypted. This means that your password could be snooped if you use it make an <b><code>ftp</code></b> connection. If you wish to transfer files between two systems where you have accounts it is better to use the commands <b><code>sftp</code></b> (secure file transfer program) or <b><code>scp</code></b> (secure remote file copy program) if available, as they provide encrypted file transfer. See the section on <code><code>ssh</code></code> for examples.</p>
<p>Some systems offer a service called "anonymous ftp", usually to allow  general access to certain archives. 
To use such a service, enter <code>anonymous</code> instead of your username when you ftp to the system. 
It is fairly standard practice for the remote system to ask you to give your email address in place of a password. 
Once you have logged on you will have read access in a limited set of directories, usually within the /pub directory tree. </p>

<!-- PAGE MARKER -->
<p style="page-break-after: always;">&nbsp;</p><br/><br/><br/><br/><br/><hr><br/>
<dl>

<dt><code><b>ftp -i ftp.ncbi.nlm.nih.gov</b></code></dt>
<dd>If the connection to the remote system ftp.ncbi.nlm.nih.gov is established, it will respond:</dd>
<br/><pre><code>Connected to ftp.ncbi.nlm.nih.gov.
220-
 This warning banner provides privacy and security notices consistent with 
 applicable federal laws, directives, and other federal guidance for accessing 
 this Government system, which includes all devices/storage media attached to 
 this system. This system is provided for Government-authorized use only. 
 Unauthorized or improper use of this system is prohibited and may result in 
 disciplinary action and/or civil and criminal penalties. At any time, and for 
 any lawful Government purpose, the government may monitor, record, and audit 
 your system usage and/or intercept, search and seize any communication or data 
 transiting or stored on this system. Therefore, you have no reasonable 
 expectation of privacy. Any communication or data transiting or stored on this 
 system may be disclosed or used for any lawful Government purpose.
220 FTP Server ready.
<b>Name</b> (ftp.ncbi.nlm.nih.gov:user1): </code></pre>
<dd> (supposing <code>user1</code> is your username on your local system). 
Enter <code>anonymous</code> and press <code>Return</code>. You will then be asked to enter your email address instead of a password. </dd>
</dl>

<!-- PAGE MARKER -->
<p style="page-break-after: always;">&nbsp;</p><br/><br/><br/><br/><br/><hr><br/>
<dl>
<br/> After logging in, some Unix commands, such as <b>cd</b> and <b>ls</b>, will be available. Other useful commands are:
<br/><br/><dt><code><b>help</b></code></dt><dd>lists the commands available to you while using <b>ftp</b></dd>
<br/><dt><code><b>get</b> remote1 local1</code></dt><dd>creates a copy on your local system of the file <code>remote1</code> from the remote system. 
On your local system this new file will be called <code>local1</code>. If no name is specified for the file on the local system, 
it will be given the same name as the file on the remote system.</dd>
<br/><dt><code><b>mget</b> remote1* </code></dt><dd>retrieves all files starting with the name <code>remote1</code> from the remote system and puts them in your local working directory. </dd>
<br/><dt><code><b>quit</b></code></dt><dd>finishes the <b>ftp</b> session. <b>bye</b> and <b>close</b> can also be used to do this. </dd>
</dl>

<!-- PAGE MARKER -->
<p style="page-break-after: always;">&nbsp;</p><br/><br/><br/><br/><br/><hr><br/>

<h2><a name="grep" id="grep">grep, zgrep</a> - searches files for a specified string or expression</h2>
<br/><b><code>grep</code></b> searches for lines containing a specified pattern and, by default, writes them to the standard output.
<br/><b><code>zgrep</code></b> does the same thing as <b><code>grep</b></code>, but takes a gzipped file as input.
<br/><b>BOTH are case sensitive!</b>
<dl>
<br/><dt><code><b>grep</b> "motif1" file1</code></dt><dd>searches the file <code>file1</code> for lines containing the pattern <code>"motif1"</code>. </dd>
<br/><dt><code><b>grep</b> "^motif1" file1</code></dt><dd>searches the file <code>file1</code> for lines containing the pattern <code>"motif1"</code> at the beginning of a word/string. </dd>
<br/><dt><code><b>grep</b> "motif1$" file1</code></dt><dd>searches the file <code>file1</code> for lines containing the pattern <code>"motif1"</code> at the end of a word/string. </dd>
<br/><dt><code><b>grep</b> -w "motif1" file1</code></dt><dd>searches the file <code>file1</code> for lines containing the word <code>"motif1"</code>. </dd>
</dl>

<!-- PAGE MARKER -->
<p style="page-break-after: always;">&nbsp;</p><br/><br/><br/><br/><br/><hr><br/>
<dl>
<br/><dt><code><b>cat file1 | grep "motif1"</b></code></dt><dd>will apply <code><b>grep</b></code> to the standard input/output via a pipe, looking for lines containing <code>motif1</code>.</dd>
<br/><dt><code><b>grep</b> "motif1" file1 file2 filen</code></dt><dd>will search the files <code>file1</code>, <code>file2</code> and <code>filen</code> for the pattern <code>motif1</code>.</dd>
<br/><dt><code><b>grep</b> "motif1" a*</code></dt><dd>will search all the files in the current directory with names beginning with 'a' for the pattern <code>motif1</code>.  In this instance, the <code>*</code> is a wild-card that means "anything".</dd>
<br/><dt><code><b>grep</b> -c "motif1" file1</code></dt><dd>will count the number of lines containing <code>motif1</code> instead of outputting the lines themselves.</dd>
<br/><dt><code><b>grep</b> -m3 "motif1" file1</code></dt><dd>will output the first three lines that contain <code>motif1</code>.</dd>
</dl>

<!-- PAGE MARKER -->
<p style="page-break-after: always;">&nbsp;</p><br/><br/><br/><br/><br/><hr><br/>
<dl>
<br/><dt><code><b>grep</b> -v "motif1" file1</code></dt><dd>will write out the lines of <code>file1</code> that do NOT contain <code>motif1</code>.</dd>
<br/><dt><code><b>grep</b> -E "motif1|motif2" file1</code></dt><dd>searches the file <code>file1</code> for lines containing one or more of the two patterns <code>motif1</code> and <code>motif2</code>.</dd>
<br/><dt><code><b>grep</b> -Ei "motif1|motif2" file1</code></dt><dd>searches, in a case-insensitive mannner, the file <code>file1</code> for lines containing one or more of the two patterns <code>motif1</code> and <code>motif2</code>.</dd>
<br/><dt><code><b>cat file1 | grep "motif1"</b></code></dt><dd>will apply <code><b>grep</b></code> to the standard input/output via a pipe, looking for lines containing <code>motif1</code>.</dd>
<br/><dt><code><b>cat file1 | grep "motif1" | grep "motif3"</b></code></dt><dd>will apply <code><b>grep</b></code> to the standard input/output via a pipe, looking for lines containing <code>motif1</code> and then within those, lines that contain <code>motif3</code>.  The lines output will thus have <code>motif1</code> AND <code>motif3</code>.</dd>  
<br/><dt><code><b>grep --help</b></code></dt><dd>will tell you about the huge number of options available.</dd> 
</dl>


<!-- PAGE MARKER -->
<p style="page-break-after: always;">&nbsp;</p><br/><br/><br/><br/><br/><hr><br/>

<h2><a name="gzip" id="gzip">gzip, pigz</a> - compress a file</h2>
<b><code>gzip</code></b> reduces the size of named files, replacing them with files of the same name extended by <b><code>.gz</code></b> . The amount of space saved by compression varies.  <code>pigz</code> is a similar utility that is able to work over multiple threads, and thus can be substantially faster.
<dl>
<br/><dt><code><b>gzip</b> file1</code></dt><dd>results in a compressed file called <code>file1.gz</code>, and deletes <code>file1</code>.</dd>
<br/><dt><code><b>gzip</b> -v file2</code></dt><dd>compresses <code>file2</code> and gives information, in the format shown below, on the percentage of the file's size that has been saved by compression:-<br /><code>file2 : Compression 50.26 -- replaced with file2.gz</code></dd>
</dl>
<br/>To restore files to their original state use the command <code><b>gunzip</b></code> or <code><b>gzip -d</b></code>.
<dl>
<dt><code><b>gzip</b> -d file2.gz</code></dt><dd>will replace <code>file2.gz</code> with the uncompressed file <code>file2</code>.</dd>
</dl>

<!-- PAGE MARKER -->
<p style="page-break-after: always;">&nbsp;</p><br/><br/><br/><br/><br/><hr><br/>

<h2><a name="head" id="head">head, tail</a> - display lines of a file</h2>
<dl>
<br/><dt><code><b>head -n5</b> file1</code></dt><dd>displays the first 5 lines of <code>file1</code>.</dd>
<br/><dt><code><b>tail -n5</b> file1</code></dt><dd>displays the last 5 lines of <code>file1</code>.</dd>
<br/><dt><code><b>tail -n +2 </b> file1</code></dt><dd>shows all lines of <code>file1</code> from the second line onwards.</dd>
<br/><dt><code><b>head -n5</b> file1*</code></dt><dd>displays the first 5 lines of all files whose names start with file1.</dd>
<br/><dt><code><b>tail -n5</b> file1*</code></dt><dd>displays the last 5 lines of all files whose names start with file1.</dd>
<br/><dt><code><b>tail --silent -c5</b> file1*</code></dt><dd>outputs the last 5 characters of all files whose names start with file1, silently suppressing the filenames. Notice that the count includes the newline character at the end of each line, so you'll get 4 characters, visible or otherwise, back.</dd>
</dl>

<!-- PAGE MARKER
<br/><br/><br/><br/><br/><br/><hr><br/>
<h2><a name="help" id="help">help</a> - display information about bash built-in commands</h2>
<p><code><b>help</b></code> gives access to information about builtin commands in the bash shell. Using <code><b>help</b></code> on its own will give a list of the commands it has information about. <code><b>help</b></code> followed by the name of one of these commands will give information about that commands. <code><b>help history</b></code>, for example, will give details about the bash shell history listings.</p>

<!-- PAGE MARKER
<br/><br/><br/><br/><br/><br/><hr><br/>

<h2><a name="info" id="info">info</a> - read online documentation</h2>
<p><code><b>info</b></code> is a hypertext information system. Using the command <code><b>info</b></code> on its own will enter the info system, and give a list of the major subjects it has information about. Use the command <code><b>q</b></code> to exit <code><b>info</b></code>. For example, <code><b>info bash</b></code> will give details about the bash shell.</p>
-->

<!-- PAGE MARKER -->
<p style="page-break-after: always;">&nbsp;</p><br/><br/><br/><br/><br/><hr><br/>

<h2><a name="kill" id="kill">kill</a> - kill a process</h2>
<p>To kill a process using <code><b>kill</b></code> requires knowing the process id (PID). 
This can be found by using the command <b><a href="#ps">ps</a>:</b>
<dl>
<dt><code><b>ps</b> aux | grep "myoutofcontrolprocess"</code>
<pre><code>user    <b>4724</b>  0.0  0.0  39904  4028 pts/3    R+   Sep07   0:14 myoutofcontrolprocess</code></pre></dt>
<dd>will identify the process.</dd>
<br/><dt><code><b>kill STOP</b> 4724</code></dt><dd>will stop (but not remove, i.e. pause) the process.</dd>
<br/><dt><code><b>kill CONT</b> 4724</code></dt><dd>will continue the STOPped process.</dd>
<br/><dt><code><b>kill</b> 4724</code></dt><dd>should kill the process.</dd>
<br/><dt><code><b>kill -9</b> 4724</code></dt><dd>will kill the process, and all its dependants.</dd>
</dl>

<!-- PAGE MARKER
<br/><br/><br/><br/><br/><br/><hr><br/>

<h2><a name="lpr" id="lpr">lpr</a> - print out a file</h2>
<p><code><b>lpr</b></code> is used to send the contents of a file to a printer. If the printer is a laserwriter, and the file contains PostScript, then the PostScript will be interpreted and the results of that printed out.</p>
<dl>
<dt><code><b>lpr</b> -Pprinter1 file1</code></dt><dd>will send the file <code>file1</code> to be printed out on the printer <code>printer1</code>. To see the status of the job on the printer queue use</dd>
<dt><code><b>lpq</b> -Pprinter1</code></dt><dd>for a list of the jobs queued for printing on <code>printer1</code>. (This may not work for remote printers.)</dd>
<dl>
-->

<!-- PAGE MARKER -->
<p style="page-break-after: always;">&nbsp;</p><br/><br/><br/><br/><br/><hr><br/>

<h2><a name="ls" id="ls">ls</a> - list names of files in a directory</h2>
<p><code><b>ls</b></code> lists the contents of a directory, and can be used to obtain information on the files and directories within it.</p>
<dl>
<dt><code><b>ls</b></code></dt><dd>lists the contents of the current directory in multiple columns across the screen, alphabetically, case sensitive.</dd>
<br/><dt><code><b>ls</b> -1</code></dt><dd>lists the contents of the current directory in a <b>single</b> column on the screen.</dd>
<br/><dt><code><b>ls</b> dir1</code></dt><dd>lists the names of the files and directories in the directory <code>dir1</code>, (excluding files whose names begin with . ).</dd>
<br/><dt><code><b>ls</b> -R dir1</code></dt><dd> also lists the contents of any subdirectories that <code>dir1</code> contains.</dd>

<!-- PAGE MARKER -->
<p style="page-break-after: always;">&nbsp;</p><br/><br/><br/><br/><br/><hr><br/>
<dt><code><b>ls</b> -a dir1</code></dt><dd>will list all contents of <code>dir1</code>, (including files whose names begin with . ).</dd>
<br/><dt><code><b>ls</b> -l file1</code></dt><dd>gives long details of the access permissions for the file <code>file1</code>, its size in kbytes, and the time it was last altered.</dd>
<br/><dt><code><b>ls</b> -l dir1</code></dt><dd>gives long format information on the contents of the directory <code>dir1</code>.</dd>

<!-- PAGE MARKER -->
<p style="page-break-after: always;">&nbsp;</p><br/><br/><br/><br/><br/><hr><br/>
<dt><code><b>ls</b> -al </code></dt><dd>gives full information on the contents of the current directory.</dd>
<br/><dt><code><b>ls</b> -alrt </code></dt><dd>gives, in reverse time order, full information on the contents of the current directory.</dd>
<br/><dt><code><b>ls</b> -ld dir1</code></dt><dd> To obtain the information on <code>dir1</code> itself, rather than its contents.</dd>
</dl>

<!-- PAGE MARKER -->
<p style="page-break-after: always;">&nbsp;</p><br/><br/><br/><br/><br/><hr><br/>

<h2><a name="man" id="man">man</a> - display an on-line manual page</h2>
<p><code><b>man</b></code> displays on-line reference manual pages.</p>
<dl>
<dt><code><b>man</b> command1</code></dt><dd>will display the manual page for <code>command1</code>, e.g <code><b>man</b> cp</code>, <code><b>man</b> man</code>.</dd>
<br/><dt><code><b>man -k</b> keyword</code></dt><dd>lists the manual page subjects that have keyword in their headings. This is useful if you do not yet know the name of a command you are seeking information about.</dd>
<br/><dt><code><b>man -M</b>path command1</code></dt><dd>is used to change the set of directories that man searches for manual pages on <code>command1</code></dd>
<dl>

<!-- PAGE MARKER -->
<p style="page-break-after: always;">&nbsp;</p><br/><br/><br/><br/><br/><hr><br/>

<h2><a name="mkdir" id="mkdir">mkdir</a> - make a directory</h2>
<p><code><b>mkdir</b></code> is used to create new directories. In order to do this you must have write permission in the parent directory of the new directory.</p>
<dl>
<dt><code><b>mkdir</b> newdir</code></dt><dd>will make a new directory called <code>newdir</code>.</dd>
<br/><dt><code><b>mkdir -p</b> dir1/dir2/newdir</code></dt><dd>will create newdir and its parent directories <code>dir1</code> and <code>dir2</code>, if these do not already exist.</dd>
<dl>

<!-- PAGE MARKER -->
<p style="page-break-after: always;">&nbsp;</p><br/><br/><br/><br/><br/><hr><br/>

<h2><a name="more" id="more">more, zmore</a> - scan through a text file page by page</h2>
<p><code><b>more</b></code> displays the contents of a file on a terminal one screenful at a time.</p>
<p><code><b>zmore</b></code> does the same as <code>more</code>, but takes a gzipped file as input.</p>
<dl>
<dt><code><b>more</b> file1</code></dt><dd>starts by displaying the beginning of <code>file1</code>. It will scroll up one line every time the return key is pressed, and one screenful every time the space bar is pressed. Type <b>?</b> for details of the commands available within <code><b>more</b></code>. Type <b>q</b> if you wish to quit more before the end of <code>file1</code> is reached.</dd>
<br/><dt><code><b>more -</b>n file1</code></dt><dd>will cause <code>n</code> lines of <code>file1</code> to be displayed in each screenful instead of the default (which is two lines less than the number of lines that will fit into the terminal's screen).</dd>
<dl>

<!-- PAGE MARKER -->
<p style="page-break-after: always;">&nbsp;</p><br/><br/><br/><br/><br/><hr><br/>

<h2><a name="mv" id="mv">mv</a> - move or rename files or directories</h2>
<p><code><b>mv</b></code> is used to change the name of files or directories, or to move them into other directories.</p>
<dl>
<dt><code><b>mv</b> file1 file2</code></dt><dd>changes the name of a file from <code>file1</code> to <code>file2</code> unless <code>dir2</code> already exists, in which case <code>dir1</code> will be moved into <code>dir2</code>.</dd>
<br/><dt><code><b>mv</b> dir1 dir2</code></dt><dd>changes the name of a directory from <code>dir1</code> to <code>dir2</code>.</dd>
<br/><dt><code><b>mv</b> file1 file2 dir3</code></dt><dd>moves the files <code>file1</code> and <code>file2</code> into the directory <code>dir3</code>.</dd>
<dl>

<!-- PAGE MARKER 
<br/><br/><br/><br/><br/><br/><hr><br/>

<h2><a name="nice" id="nice">nice</a> - change the priority at which a job is being run</h2>
<p><code><b>nice</b></code> causes a command to be run at a lower than usual priority. <code><b>nice</b></code> can be particularly useful when running a long program that could cause annoyance if it slowed down the execution of other users' commands. An example of the use of <code><b>nice</b></code> is</p>
<dl>
<dt><code><b>nice gzip</b> file1</code></dt><dd>which will execute the compression of <code>file1</code> at a lower priority</dd><dd>If the job you are running is likely to take a significant time, you may wish to run it in the background, i.e. in a subshell. To do this, put an ampersand <b>&amp;</b> after the name of your command or script. For instance,</dd>
<dt><code><b>rm -r</b> mydir <b>&amp;</b></code></dt><dd>is a background job that will remove the directory <code>mydir</code> and all its contents. </dd><dd>The command <code>jobs</code> gives details of the status of background processes, and the command <code>fg</code> can be used to bring such a process into the foreground. </dd>
<dl>
-->

<!-- PAGE MARKER -->
<p style="page-break-after: always;">&nbsp;</p><br/><br/><br/><br/><br/><hr><br/>

<h2><a name="passwd" id="passwd">passwd</a> - change your password</h2>
Use <code><b>passwd</b></code> when you wish to change your password. 
<br/><br/>You will be prompted once for your current password, and twice for your new password. 
<br/><br/>Neither password will be displayed on the screen.
<br/><br/>Use with care....!


<!-- PAGE MARKER -->
<p style="page-break-after: always;">&nbsp;</p><br/><br/><br/><br/><br/><hr><br/>

<h2><a name="paste" id="paste">paste</a> - join files horizontally</h2>
<p>For each corresponding line, <code><b>paste</b></code> will append the contents of each file at that line to its output along with a tab. When it has completed its operation for the last file, paste will output a newline character and move on to the next line.
<dl>
<dt><code><b>paste</b> file1 file2 > file3</code></dt><dd>line by line, paste the contents of <code>file2</code> next to the contents of <code>file1</code>, separated by a tab, and output to <code>file3</code>.</dd>
<br/><dt><code><b>paste -d az </b> file1 file2 file3 > file123 </code></dt><dd>line by line, paste the contents of <code>file1</code>, <code>file2</code> and <code>file3</code>, next to each other, alternately <b>d</b>elimited by "a" and then "z", and output the result to <code>file123</code>.</dd>
<br/><dt><code><b>paste -s</b> file1 file2 > file3</code></dt><dd>output the contents of <code>file1</code> and <code>file2</code> serially as tab-separated items in horizontal orientation to <code>file3</code></dd>
<!-- <pre><code><b>cat file1</b>
file1line1
file1line2
file1line3

<b>cat file2</b>
file2line1
file2line2
file2line3-->
<pre><code><b>paste file1 file2</b>
file1line1	file2line1
file1line2	file2line2
file1line3	file2line3

<b>paste -s file1 file2</b>
file1line1	file1line2	file1line3
file2line1	file2line2	file2line3
</code></pre>
</dl>

<!-- PAGE MARKER -->
<p style="page-break-after: always;">&nbsp;</p><br/><br/><br/><br/><br/><hr><br/>

<h2><a name="ps" id="ps">ps</a> - list processes</h2>
<code><b>ps</b></code> displays information on processes currently running on your machine. This information includes the process id, the controlling terminal (if there is one), the cpu time used so far, and the name of the command being run.<br />
<br /><b>NOTE:  <code>ps</code></b> is a command whose options vary considerably in different versions of Unix. Use <code><b>man</b> ps</code> for details of all the options available on the machine you are using.<br />
<dl>
<br /><dt><code><b>ps</b></code></dt><dd>gives brief details of your own processes in your current session.</dd>
<br /><dt><code><b>ps -au</b></code></dt><dd>gives fuller details of your own processes in your current session.</dd>
<br /><dt><code><b>ps -au</b> user1</code> </dt><dd>gives fuller details of processes owned by <code>user1</code> in your current session.</dd>
<br /><dt><code><b>ps aux</b></code> </dt><dd>gives fuller details of all processes owned by all users.  Note missing "-", but effect depends on what flavour of Unix...</dd>
</dl>

<!-- PAGE MARKER 
<br/><br/><br/><br/><br/><br/><hr><br/>


<h2><a name="quota" id="quota">quota</a> - disk quota and usage</h2>
<p><code><b>quota</b></code> gives information on a user's disk space quota and usage.</p>
<dl>
<dt><code><b>quota</b></code></dt><dd>will only give details of where you have exceeded your disc quota on local disks, whereas</dd>
<dt><code><b>quota -v</b></code></dt><dd>will display your quota and usage, whether the quota has been exceeded or not, and includes information on disks mounted from other machines, as well as the local disks.</dd>
</dl>

<!-- PAGE MARKER -->
<p style="page-break-after: always;">&nbsp;</p><br/><br/><br/><br/><br/><hr><br/>


<h2><a name="rm" id="rm">rm</a> - remove files or directories: PERMANENTLY...</h2>
<p><code><b>rm</b></code> is used to remove files. In order to remove a file you must have write permission in its directory, but it is not necessary to have read or write permission on the file itself.</p>
<dl>
<br/><dt><code><b>rm</b> file1</code></dt><dd>will delete the file <code>file1</code>, permanently, so use with care.</dd>
<br/><dt><code><b>rm -i</b> file1</code></dt><dd>instead, you will be asked if you wish to delete <code>file1</code>, and the file will not be deleted unless you answer <code><b>y</b></code>. This is a useful safety check when deleting lots of files, and you should consider aliasing it to minimise unwanted unhappy events....</dd>
<br/><dt><code><b>rm -r</b> dir1</code></dt><dd>recursively deletes the contents of <code>dir1</code>, its subdirectories, and <code>dir1</code> itself, and should be used with caution.</dd>
<br/><dt><code><b>rm -fr</b> dir1</code></dt><dd>forcibly and recursively deletes the contents of <code>dir1</code>, its subdirectories, and <code>dir1</code> itself.  This is a "nuclear" option, so be very afraid!</dd>
</dl>
<!-- PAGE MARKER -->
<p style="page-break-after: always;">&nbsp;</p><br/><br/><br/><br/><br/><hr><br/>


<h2><a name="rmdir" id="rmdir">rmdir</a> - remove a directory</h2>
<p><code><b>rmdir</b></code> removes named empty directories. If you need to delete a non-empty directory <code><b>rm -r</b></code> can be used instead.</p>
<dl>
<dt><code><b>rmdir</b> exdir</code></dt><dd>will remove the empty directory <code>exdir</code>.</dd>
</dl>

<!-- PAGE MARKER -->
<p style="page-break-after: always;">&nbsp;</p><br/><br/><br/><br/><br/><hr><br/>

<h2><a name="sort" id="sort">sort</a> - sort and collate lines</h2>
The command <code><b>sort</b></code> sorts and collates lines in files, sending the results to the standard output. 
<br/><br/>If no file names are given, <code><b>sort</b></code> acts on the standard input. 
<br/><br/>By default, <code><b>sort</b></code> sorts lines using a character by character comparison, working from left to right, and using the order of the ASCII character set.
<dl>
<br/><dt><code><b>sort -d</b></code></dt><dd>uses "dictionary order", in which only letters, digits, and white-space characters are considered in the comparisons.</dd>
<br/><dt><code><b>sort -r</b></code></dt><dd>reverses the order of the collating sequence.</dd>
<br/><dt><code><b>sort -n</b></code></dt><dd>sorts lines according to the arithmetic value of leading numeric strings. Leading blanks are ignored when this option is used, (except in some System V versions of <code><b>sort</b></code>, which treat leading blanks as significant. To be certain of ignoring leading blanks use <code><b>sort -bn</b></code> instead).</dd>

<!-- PAGE MARKER -->
<p style="page-break-after: always;">&nbsp;</p><br/><br/><br/><br/><br/><hr><br/>

<dt><code><b>sort -t$'\t' -k1,1</b> file1</code></dt><dd>sorts the file <code>file1</code> on the first column; 
default field delimiter is "non-blank to blank" transition so tab and space should work equally well; adding the <code>-t$'\t'</code> is a safer way to ensure tabs are used. 
<br/>We write the column twice (e.g. -k1,1) to ensure that sort is only using the given column (in this case, column 1) when determining the "sort key order"; everything on each line can be output, but the order will determined by the -k1,1 sort key.</dd>
<br/><dt><code><b>sort -k1,1 -k2,2nr </b> file1</code></dt><dd>sorts the file <code>file1</code> on the first column, and then on the second column, treating the latter as numeric, outputting the lines in decreasing numeric value order of column 2.</dd>
<br/><dt><code><b>cat file1 | grep "motif1" | sort -k1,1 -k2,2nr</b></code></dt>
<dd>....cats the file <code>file1</code>
<br/>....retains any line that has the string <code>"motif1"</code> in it, 
<br/>....sorts on the first column, and then on the second column, treating the latter as numeric, outputting the lines in decreasing numeric value of column 2.</dd>

</dl>

<!-- PAGE MARKER -->
<p style="page-break-after: always;">&nbsp;</p><br/><br/><br/><br/><br/><hr><br/>

<h2><a name="ssh" id="ssh">ssh</a> - secure remote access</h2>
<code><b>ssh</b></code> (also known as <code><b>slogin</b></code>) is used for logging onto a remote system, and provides secure encrypted communications between the local and remote systems using the SSH  protocol. 
<br/><br/>The remote system must be running an SSH server for such  connections to be possible. You can ssh to a machine using its name, or, if you know it, its unique IP address.  For example:<br/><br/>
<dl>
<dt><code><b>ssh</b> bioinfmsc5.bio.ed.ac.uk</code> <br/>or<br/><code><b>ssh</b> 129.215.237.197</code></dt><dd>initiates a login connection to the course server bioinfmsc5.bio.ed.ac.uk, which has IP address 129.215.237.197.</dd>
<br/><dt><code><b>ssh</b> someuseruun@bioinfmsc5.bio.ed.ac.uk</code></dt><dd>initiates a login connection for <code>someuseruun</code> to the course server bioinfmsc5.bio.ed.ac.uk.  
<br/><br/>You will need to use your EASE login details (both username and password).</dd>
</dl>

<!-- PAGE MARKER -->
<p style="page-break-after: always;">&nbsp;</p><br/><br/><br/><br/><br/><hr><br/>

<br/>If you wish to transfer files over an encrypted connection you can use <b><code>sftp</code></b> (secure remote file transfer program) or <code><b>scp</b></code> (secure remote file copy program); authentication is handled as for <b><code>ssh</code></b>. 
<dl>
<br/><dt><code><b>sftp</b> bioinfmsc5.bio.ed.ac.uk</code></dt>
<dd> Once you have authenticated access to bioinfmsc5.bio.ed.ac.uk, you will be in  your home directory. 
You can use the command <b><code>cd</b></code> to change directories on bioinfmsc5.bio.ed.ac.uk and <b><code>lcd</code></b> to change directories on your local system; 
<code><b>get</b></code> can be used to transfer files from the remote system, and <b><code>put</code></b> to transfer files to the remote system. 
The command <code><b>quit</b></code> will terminate the <b><code>sftp</code></b> session. </dd>

<br />Alternatively, you could use <code><b>scp</b></code> to transfer files. 
<br/><br/><dt><code><b>scp</b> remoteserver:file1 newfile1</code></dt><dd>is used to transfer a copy of the file <code>file1</code> in your home directory on the remote server to the current directory on the local system, naming the file <code>newfile1</code>. </dd>
<br/><br/><dt><code><b>scp</b> file2 remoteserver:newfile2</code></dt><dd>to copy the local file <code>file2</code> to the remote system, calling the copy <code>newfile2</code></dd>
</dl>

<!-- PAGE MARKER -->
<p style="page-break-after: always;">&nbsp;</p><br/><br/><br/><br/><br/><hr><br/>

<h2><a name="tar" id="tar">tar</a> - create and use archives of files</h2>
<code><b>tar</b></code> can be used to create and manage an archive of a set of files. Tar stands for TapeARchive.

<dl>
<br/><dt><code><b>tar cf</b> archive1.tar</code></dt><dd>creates an archive file called <code>archive1.tar</code> containing the contents of the current directory (and any subdirectories it contains). The <code><b>c</b></code> option stands for "create" and the <b><code>f</code></b> for "filename". </dd>
<br/><dt><code><b>tar cf</b> archive1.tar *.html</code></dt><dd>creates an archive file called <code>archive1.tar</code> containing all html files in the current directory.</dd>
<br/><br/><dt><code><b>tar cf</b> archive2.tar mydir</code></dt><dd>creates an archive file called <code>archive2.tar</code> containing the contents of the directory <code>mydir</code>.</dd>
<br/><br/><dt><code><b>tar tvf</b> archive1.tar</code></dt><dd>lists the contents of the archive file <code>archive1.tar</code>. The <code><b>t</b></code> stands for "list" and the <b><code>v</code></b> for "verbose listing". </dd>
<!-- PAGE MARKER -->
<p style="page-break-after: always;">&nbsp;</p><br/><br/><br/><br/><br/><hr><br/>

<dt><code><b>tar xf</b> archive1.tar</code></dt><dd>extracts the contents of <code>archive1.tar</code> and copy them into the current directory. The <code><b>x</b></code> stands for "extract". </dd>
<br/><br/><dt><code><b>tar xf</b> archive1.tar file2</code></dt><dd>extracts <code>file2</code> from <code>archive1.tar</code> (if <code>file2</code> is in the archive). </dd>
<br/><br/><dt><code><b>tar uf</b> archive1.tar file2</code></dt><dd>If <code>file2</code> is not already in the archive it will be added. The <code><b>u</b></code> stands for "update". If there is already a file called <code>file2</code> in the archive, <code>file2</code> will be appended to the archive if it has a more recent timestamp than the <code>file2</code> already in the archive. This means the most recent version of <code>file2</code> will be obtained when <code>file2</code> is extracted from the archive. </dd>
<dl>

<!-- PAGE MARKER -->
<p style="page-break-after: always;">&nbsp;</p><br/><br/><br/><br/><br/><hr><br/>

<h2><a name="uniq" id="uniq">uniq</a> - unique</h2>
<p><code><b>uniq</b></code> is frequently used after or with the <code><b>sort</b></code> command to determine frequencies of lines/elements.
<dl>
<dt><code><b>uniq</b> file1</code></dt><dd>listing of non-redundant lines in <code>file1</code>, but only if it is <b>sequential</b> lines that are not identical.</dd>
<br/><br/><dt><code><b>cat file1 | sort | uniq -c </b></code></dt><dd>number of occurrences of each non-redundant line of <code>file1</code>.</dd>
<br/><br/><dt><code><b>sort file1 | uniq -c </b></code></dt><dd>does the same thing, just a shorter command: count the number of occurrences of each non-redundant line of <code>file1</code>.</dd>
</dl>

<!-- PAGE MARKER -->
<p style="page-break-after: always;">&nbsp;</p><br/><br/><br/><br/><br/><hr><br/>

<h2><a name="wc" id="wc">wc</a> - counting words, letters, lines of files</h2>
<dl>
<dt><code><b>wc</b> file1</code></dt><dd>newline count, word count, and character/byte count of <code>file1</code>.</dd>
<dt><br/><code><b>cat file1</b></code></dt>
<pre><i>file1line1
file1line2
file1line3</i></pre>
<dt><code><b>wc file1</b></code></dt>
<pre><i> 3  3 33 file1</i></pre>
<br/><dt><code><b>wc -c</b> file1</code></dt><dd>number of characters in <code>file1</code>.</dd>
<br/><dt><code><b>wc -w</b> file1</code></dt><dd>number of words in <code>file1</code>.</dd>
<br/><dt><code><b>wc -l</b> file1</code></dt><dd>number of lines in <code>file1</code>.</dd>

<!-- PAGE MARKER -->
<p style="page-break-after: always;">&nbsp;</p><br/><br/><br/><br/><br/><hr><br/>

</dl>
<br/> <br/><br/><br/><br/>
<a href="Lecture01_UnixIntro_Exercises.html">...and now let's try the exercises...</a>
</body></html>
